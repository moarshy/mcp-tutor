# MCP Documentation Tutor - Focused Implementation Specification
## Building a Documentation Tutor from GitHub Repository

---

## ðŸŽ¯ Project Overview

**Goal**: Create a focused, production-ready example of our MCP educational architecture by building a documentation tutor that ingests the MCP documentation repository and provides intelligent tutoring on Model Context Protocol concepts.

**Source**: https://github.com/modelcontextprotocol/docs  
**Domain**: Model Context Protocol (MCP) documentation and concepts  
**Target Users**: Developers learning MCP  
**Implementation**: Python MCP Server + DSPy Agent

---

## ðŸ§­ Why This Example is Perfect

### **Focused Scope with Clear Purpose**
- **Single domain**: MCP documentation (manageable complexity)
- **Real-world utility**: Helps developers learn MCP effectively
- **Self-demonstrating**: Uses MCP to teach MCP (meta-learning)
- **Measurable outcomes**: Can assess understanding of specific MCP concepts

### **Rich Educational Content**
- **Conceptual knowledge**: Core MCP architecture, protocols, patterns
- **Practical examples**: Code samples, implementation patterns
- **Progressive complexity**: Basic concepts â†’ advanced implementations
- **Clear prerequisites**: Well-defined learning paths

### **Demonstrates Full Architecture**
- **Content processing**: GitHub â†’ structured educational content
- **MCP capabilities**: Tools, prompts, and resources working together
- **DSPy integration**: Adaptive tutoring with reasoning
- **Educational AI**: Purpose-built for learning outcomes

---

## ðŸ—ï¸ Architecture: Every Component Has Purpose

### **1. Content Processing Pipeline**

```python
class GitHubRepositoryIngester:
    """
    Purpose: Convert GitHub documentation into structured educational content
    Why needed: Raw documentation isn't optimized for learning - needs chunking,
    concept extraction, and difficulty assessment for effective tutoring
    """
    
    async def clone_repository(self, repo_url: str) -> RepositoryContent:
        """Clone and validate repository structure"""
        # Implementation: git clone, validate docs structure
        
    async def extract_documentation_files(self, repo: RepositoryContent) -> List[DocumentFile]:
        """Filter for educational content (.md, .mdx files) and ignore non-educational files"""
        # Implementation: scan for .md/.mdx, exclude configs/templates
        
    async def parse_markdown_structure(self, files: List[DocumentFile]) -> List[DocumentSection]:
        """Extract hierarchical structure (headers, code blocks, examples)"""
        # Implementation: markdown AST parsing, extract sections and code

class MCPConceptExtractor:
    """
    Purpose: Extract MCP-specific concepts and their relationships
    Why needed: Generic content processing won't understand MCP domain -
    need specialized extraction for tools, prompts, resources, protocols
    """
    
    async def identify_mcp_concepts(self, content: DocumentSection) -> List[MCPConcept]:
        """Extract MCP-specific concepts: tools, prompts, resources, servers, clients"""
        # Implementation: pattern matching for MCP terminology and structures
        
    async def extract_code_examples(self, content: DocumentSection) -> List[CodeExample]:
        """Find and classify code examples (TypeScript, Python, JSON-RPC)"""
        # Implementation: parse code blocks, classify by language and purpose
        
    async def build_prerequisite_graph(self, concepts: List[MCPConcept]) -> ConceptGraph:
        """Determine learning dependencies between MCP concepts"""
        # Implementation: analyze concept references and build dependency tree

class LearningPathGenerator:
    """
    Purpose: Create structured learning paths for MCP mastery
    Why needed: Documentation order != optimal learning order.
    Need to scaffold learning from basic to advanced concepts
    """
    
    async def generate_beginner_path(self) -> LearningPath:
        """Path: MCP Overview â†’ Core Architecture â†’ Basic Tools â†’ Simple Examples"""
        
    async def generate_developer_path(self) -> LearningPath:
        """Path: Prerequisites â†’ Server Implementation â†’ Client Integration â†’ Advanced Patterns"""
        
    async def generate_concept_path(self, target_concept: str) -> LearningPath:
        """Generate path to understand specific MCP concept (e.g., "tools", "prompts")"""
```

### **2. MCP Tools Layer (Model-Controlled)**

```python
@server.list_tools()
async def list_tools() -> list[types.Tool]:
    return [
        types.Tool(
            name="search_mcp_concepts",
            description="Search MCP documentation for specific concepts, patterns, or examples",
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {"type": "string", "description": "Concept to search for"},
                    "concept_type": {
                        "type": "string", 
                        "enum": ["tool", "prompt", "resource", "transport", "protocol", "example"],
                        "description": "Type of MCP concept to focus on"
                    },
                    "difficulty_level": {
                        "type": "string",
                        "enum": ["beginner", "intermediate", "advanced"],
                        "description": "Complexity level of explanation needed"
                    }
                },
                "required": ["query"]
            },
            annotations={
                "title": "MCP Concept Search",
                "readOnlyHint": True,
                "openWorldHint": False
            }
        ),
        # Purpose: Enables agent to dynamically find relevant MCP content
        # Why needed: Students ask varied questions - agent needs to find specific docs
        
        types.Tool(
            name="get_code_example",
            description="Retrieve working code examples for MCP concepts",
            inputSchema={
                "type": "object",
                "properties": {
                    "concept": {"type": "string", "description": "MCP concept needing example"},
                    "language": {
                        "type": "string",
                        "enum": ["typescript", "python", "javascript"],
                        "description": "Programming language preference"
                    },
                    "implementation_type": {
                        "type": "string",
                        "enum": ["server", "client", "tool", "prompt", "transport"],
                        "description": "Type of implementation example"
                    }
                },
                "required": ["concept"]
            },
            annotations={
                "readOnlyHint": True,
                "idempotentHint": True
            }
        ),
        # Purpose: Provides concrete, runnable examples for abstract concepts
        # Why needed: MCP learning requires seeing working implementations
        
        types.Tool(
            name="validate_student_code",
            description="Check if student's MCP implementation follows best practices",
            inputSchema={
                "type": "object",
                "properties": {
                    "code": {"type": "string", "description": "Student's MCP code to validate"},
                    "implementation_type": {"type": "string", "enum": ["server", "client", "tool", "prompt"]},
                    "language": {"type": "string", "enum": ["typescript", "python"]}
                },
                "required": ["code", "implementation_type"]
            },
            annotations={
                "readOnlyHint": True,
                "destructiveHint": False
            }
        ),
        # Purpose: Provides immediate feedback on code quality and correctness
        # Why needed: Students need validation that their MCP implementations are correct
        
        types.Tool(
            name="generate_learning_assessment",
            description="Create practice questions or challenges for MCP concepts",
            inputSchema={
                "type": "object",
                "properties": {
                    "concept": {"type": "string", "description": "MCP concept to assess"},
                    "assessment_type": {
                        "type": "string",
                        "enum": ["quiz", "coding_challenge", "debug_exercise", "design_problem"],
                        "description": "Type of assessment to generate"
                    },
                    "difficulty": {"type": "string", "enum": ["beginner", "intermediate", "advanced"]}
                },
                "required": ["concept", "assessment_type"]
            },
            annotations={
                "readOnlyHint": True,
                "idempotentHint": False
            }
        ),
        # Purpose: Creates practice opportunities for skill reinforcement
        # Why needed: Learning requires active practice, not just passive reading
        
        types.Tool(
            name="track_concept_mastery",
            description="Record and update student's understanding of MCP concepts",
            inputSchema={
                "type": "object",
                "properties": {
                    "student_id": {"type": "string"},
                    "concept": {"type": "string", "description": "MCP concept being tracked"},
                    "mastery_score": {"type": "number", "minimum": 0, "maximum": 1},
                    "evidence": {"type": "string", "description": "What demonstrated this level of understanding"}
                },
                "required": ["student_id", "concept", "mastery_score"]
            },
            annotations={
                "readOnlyHint": False,
                "destructiveHint": False,
                "idempotentHint": False
            }
        )
        # Purpose: Enables adaptive learning by tracking progress on specific concepts
        # Why needed: Agent needs to know what student has mastered to provide appropriate next steps
    ]
```

### **3. MCP Prompts Layer (User-Controlled)**

```python
@server.list_prompts()
async def list_prompts() -> list[types.Prompt]:
    return [
        types.Prompt(
            name="explain_mcp_concept",
            description="Explain an MCP concept with examples and analogies",
            arguments=[
                types.PromptArgument(
                    name="concept",
                    description="MCP concept to explain (e.g., 'tools', 'prompts', 'resources')",
                    required=True
                ),
                types.PromptArgument(
                    name="student_background",
                    description="Student's programming background (beginner, experienced, expert)",
                    required=False
                ),
                types.PromptArgument(
                    name="explanation_style",
                    description="Preferred explanation style (conceptual, practical, example-driven)",
                    required=False
                ),
                types.PromptArgument(
                    name="analogy_domain",
                    description="Domain for analogies (web APIs, databases, operating systems)",
                    required=False
                )
            ]
        ),
        # Purpose: Provides structured pedagogical approach to explaining MCP concepts
        # Why needed: Different students need different explanation styles for same concept
        
        types.Prompt(
            name="mcp_socratic_dialogue",
            description="Guide student to discover MCP concepts through Socratic questioning",
            arguments=[
                types.PromptArgument(
                    name="target_concept",
                    description="MCP concept student should discover",
                    required=True
                ),
                types.PromptArgument(
                    name="student_current_understanding",
                    description="What student currently thinks about the concept",
                    required=False
                ),
                types.PromptArgument(
                    name="misconceptions",
                    description="Common misconceptions to address",
                    required=False
                )
            ]
        ),
        # Purpose: Helps students discover MCP concepts through guided inquiry
        # Why needed: Active discovery leads to deeper understanding than passive explanation
        
        types.Prompt(
            name="mcp_code_review",
            description="Provide constructive feedback on student's MCP implementation",
            arguments=[
                types.PromptArgument(
                    name="student_code",
                    description="Student's MCP implementation code",
                    required=True
                ),
                types.PromptArgument(
                    name="implementation_goal",
                    description="What the student was trying to accomplish",
                    required=True
                ),
                types.PromptArgument(
                    name="focus_areas",
                    description="Specific aspects to focus feedback on",
                    required=False
                )
            ]
        ),
        # Purpose: Provides structured code review specifically for MCP implementations
        # Why needed: Generic code review won't catch MCP-specific patterns and best practices
        
        types.Prompt(
            name="mcp_troubleshooting_guide",
            description="Help student debug MCP implementation issues",
            arguments=[
                types.PromptArgument(
                    name="error_description",
                    description="Description of the problem student is facing",
                    required=True
                ),
                types.PromptArgument(
                    name="code_context",
                    description="Relevant code where error occurs",
                    required=False
                ),
                types.PromptArgument(
                    name="attempted_solutions",
                    description="What student has already tried",
                    required=False
                )
            ]
        ),
        # Purpose: Provides systematic debugging approach for MCP-specific issues
        # Why needed: MCP debugging requires understanding of protocol flow and common patterns
        
        types.Prompt(
            name="mcp_project_architect",
            description="Guide student through designing an MCP-based solution",
            arguments=[
                types.PromptArgument(
                    name="project_requirements",
                    description="What the student wants to build",
                    required=True
                ),
                types.PromptArgument(
                    name="constraints",
                    description="Technical or business constraints",
                    required=False
                ),
                types.PromptArgument(
                    name="student_experience_level",
                    description="Student's experience with MCP and related technologies",
                    required=False
                )
            ]
        )
        # Purpose: Helps students design MCP solutions from requirements
        # Why needed: Students need guidance on architectural decisions specific to MCP
    ]

@server.get_prompt()
async def get_prompt(name: str, arguments: dict) -> types.GetPromptResult:
    if name == "explain_mcp_concept":
        concept = arguments.get("concept", "")
        background = arguments.get("student_background", "intermediate")
        style = arguments.get("explanation_style", "practical")
        analogy_domain = arguments.get("analogy_domain", "web APIs")
        
        return types.GetPromptResult(
            messages=[
                types.PromptMessage(
                    role="system",
                    content=types.TextContent(
                        type="text",
                        text=f"""You are an expert MCP tutor with deep knowledge of the Model Context Protocol.

Your task: Explain '{concept}' to a {background} developer using a {style} approach.

Key principles for MCP education:
1. Start with WHY: Explain the problem MCP solves before diving into how
2. Use analogies from {analogy_domain} to make concepts concrete
3. Always include practical examples with working code
4. Connect concepts to the broader MCP ecosystem
5. Anticipate common misconceptions and address them proactively

Teaching approach based on style:
- conceptual: Focus on mental models and architectural understanding
- practical: Emphasize implementation details and step-by-step processes  
- example-driven: Use extensive code samples and real-world scenarios

Always end with: "What questions do you have about {concept}?" to encourage interaction."""
                    )
                ),
                types.PromptMessage(
                    role="user",
                    content=types.TextContent(
                        type="text",
                        text=f"Please explain {concept} in MCP. I want to understand it clearly."
                    )
                )
            ]
        )
        
    elif name == "mcp_socratic_dialogue":
        target_concept = arguments.get("target_concept", "")
        current_understanding = arguments.get("student_current_understanding", "")
        misconceptions = arguments.get("misconceptions", "")
        
        return types.GetPromptResult(
            messages=[
                types.PromptMessage(
                    role="system", 
                    content=types.TextContent(
                        type="text",
                        text=f"""You are a Socratic MCP tutor. Guide the student to discover '{target_concept}' through questioning.

Current student understanding: {current_understanding}
Known misconceptions to address: {misconceptions}

Socratic method for MCP concepts:
1. Start with their current understanding - ask what they think {target_concept} does
2. Guide them to examine their assumptions through probing questions
3. Help them discover contradictions or gaps in their reasoning
4. Lead them to the correct understanding through their own discovery
5. Use MCP-specific examples to test their evolving understanding

Never give direct answers. Always respond with questions that lead to insight.
Focus on the WHY behind MCP design decisions - help them understand the reasoning.

Example questioning patterns:
- "What problem do you think this solves?"
- "How might this work differently from [alternative approach]?"
- "What would happen if we didn't have this feature?"
- "Can you think of a scenario where this would be useful?"

Guide them to understand {target_concept} as part of MCP's overall architecture."""
                    )
                ),
                types.PromptMessage(
                    role="user",
                    content=types.TextContent(
                        type="text",
                        text=f"I want to understand {target_concept} in MCP. Can you help me figure it out?"
                    )
                )
            ]
        )
        
    elif name == "mcp_code_review":
        student_code = arguments.get("student_code", "")
        implementation_goal = arguments.get("implementation_goal", "")
        focus_areas = arguments.get("focus_areas", "general best practices")
        
        return types.GetPromptResult(
            messages=[
                types.PromptMessage(
                    role="system",
                    content=types.TextContent(
                        type="text",
                        text=f"""You are an expert MCP code reviewer. Provide constructive feedback on this student's implementation.

Implementation goal: {implementation_goal}
Focus areas: {focus_areas}

Review criteria for MCP code:
1. **Protocol Compliance**: Does it follow MCP specifications correctly?
2. **Schema Design**: Are input/output schemas well-defined and appropriate?
3. **Error Handling**: How does it handle errors and edge cases?
4. **Security**: Are there any security considerations missing?
5. **Best Practices**: Does it follow MCP development best practices?
6. **Code Quality**: